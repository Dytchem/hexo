[{"title":"我的ACM板子","url":"/2024/08/20/test003/","content":"\n***\n### 代码与编译\n#编译选项\n编译时加入以下命令：\n```\n-DONLINE_JUDGE -fno-tree-ch -O0 -Wall -std=c++11\n```\n\\\n#文件头\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define Inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\n// #define int long long\ntemplate <typename T>\ninline T& read(T& a) {  // 快读\n    a = 0;\n    bool f = false;\n    char c = getchar();\n    while (!isdigit(c)) {\n        f |= c == '-';\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        a = (a << 1) + (a << 3) + (c ^ 48);\n        c = getchar();\n    }\n    if (f) a = -a;\n    return a;\n}\n```\n\n***\n### 基础算法\n#模拟 \n#枚举\n#贪心 \n#排序\n#二分 #二分答案 #三分法 \n#倍增\n#构造\n\\\n#CDQ分治\n```cpp\nint f(int l, int r) {  // 区间对问题\n    if (l == r) return 0;  // 最小问题\n    int m = l + r >> 1;\n    int re = max(f(l, m), f(m + 1, r));  // 递归\n    unordered_map<int, int> mp;\n    for (int i = m, s = 0; i >= l; --i) {  // 建桶\n        mp[s += a[i]] = m + 1 - i;\n    }\n    for (int i = m + 1, s = 0; i <= r; ++i) {  // 用桶\n        re = max(re, mp[s -= a[i]] + i - m);\n    }\n    return re;\n}\n```\n也可以是基于归并排序的CDQ分治\n***\n### 数据结构\n#栈 #队列 #链表\n#哈希表\n#堆 \n#单调栈 #单调队列\n#前缀和 #差分\n\\\n#树状数组 \n这里的功能是维护前缀最大值：\n```cpp\nint bt[N];\n\ninline void add(int p, int k){\n    for (; p < N; p += p & -p)\n        bt[p] = max(bt[p], k);\n}\n\ninline int qry(int p){\n    int re = 0;\n    for (; p; p -= p & -p)\n        re = max(re, bt[p]);\n    return re;\n}\n```\n\\\n#并查集 （简单版本）\n一定要初始化`fa[i] = i`，否则合并会出问题！！！\n```cpp\n// 寻找祖先\nint find(int x) {\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\n// （非启发式）合并\nvoid hb(int x, int y) {\n    fa[find(x)] = find(y);\n}\n```\n\\\n#线段树 \n```cpp\nint n;\nll a[N];\nll tr[N << 2], lz[N << 2]; // 注意开大数组！！！！\n\nll init(int l = 1, int r = n, int p = 1) {\n    if (l == r) return tr[p] = a[l];\n    int m = l + r >> 1, ps = p << 1;\n    return tr[p] = init(l, m, ps) + init(m + 1, r, ps | 1);\n}\n\nvoid pd(int l, int r, int p) {\n    if (l == r || lz[p] == 0) return;\n    int m = l + r >> 1, ps = p << 1;\n    lz[ps] += lz[p];\n    lz[ps | 1] += lz[p];\n    tr[ps] += lz[p] * (m - l + 1);\n    tr[ps | 1] += lz[p] * (r - m);\n    lz[p] = 0;\n}\n\nvoid add(int s, int t, int k, int l = 1, int r = n, int p = 1) {\n    if (s == l && t == r) {\n        tr[p] += k * (t - s + 1);\n        lz[p] += k;\n        return;\n    }\n    pd(l, r, p);\n    int m = l + r >> 1, ps = p << 1;\n    if (s <= m) add(s, min(t, m), k, l, m, ps);\n    if (t > m) add(max(s, m + 1), t, k, m + 1, r, ps | 1);\n    tr[p] = tr[ps] + tr[ps | 1];\n}\n\nll qry(int s, int t, int l = 1, int r = n, int p = 1) {\n    if (s == l && t == r) return tr[p];\n    pd(l, r, p);\n    int m = l + r >> 1, ps = p << 1;\n    ll re = 0;\n    if (s <= m) re += qry(s, min(t, m), l, m, ps);\n    if (t > m) re += qry(max(s, m + 1), t, m + 1, r, ps | 1);\n    return re;\n}\n```\n\\\n #链式前向星 #树链剖分 #重链剖分 #LCA #树链剖分线段树\n![[重链剖分.png]]\n已知一棵包含 NN 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n\n- `1 x y z`，表示将树从`x`到`y`结点最短路径上所有节点的值都加上`z`\n    \n- `2 x y`，表示求树从`x`到`y`结点最短路径上所有节点的值之和\n    \n- `3 x z`，表示将以`x`为根节点的子树内所有节点值都加上`z`\n    \n- `4 x`， 表示求以`x`为根节点的子树内所有节点值之和\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define Inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\n// #define int long long\ntemplate <typename T>\ninline T& read(T& a) {  // 快读\n    a = 0;\n    bool f = false;\n    char c = getchar();\n    while (!isdigit(c)) {\n        f |= c == '-';\n        c = getchar();\n    }\n    while (isdigit(c)) {\n        a = (a << 1) + (a << 3) + (c ^ 48);\n        c = getchar();\n    }\n    if (f) a = -a;\n    return a;\n}\n\nconst int N = 100005;\nint n, m, r;\nll P;\nll w[N];\nint hed[N], to[N << 1], nxt[N << 1], p = 1;\n\ninline void add(int u, int v) {\n    nxt[++p] = hed[u];\n    hed[u] = p;\n    to[p] = v;\n}\n\nint fa[N], dep[N], siz[N], hs[N];\nvoid dfs1(int o = r) {\n    siz[o] = 1;\n    for (int i = hed[o]; i; i = nxt[i]) {\n        int t = to[i];\n        if (t == fa[o]) continue;\n        fa[t] = o;\n        dep[t] = dep[o] + 1;\n        dfs1(t);\n        siz[o] += siz[t];\n        if (siz[hs[o]] < siz[t]) hs[o] = t;\n    }\n}\n\nint dfn[N], rnk[N], pos = 0, top[N];\nvoid dfs2(int o = r) {\n    rnk[dfn[o] = ++pos] = o;\n    if (hs[o]) {\n        top[hs[o]] = top[o];\n        dfs2(hs[o]);\n        for (int i = hed[o]; i; i = nxt[i]) {\n            int t = to[i];\n            if (t == fa[o] || t == hs[o]) continue;\n            top[t] = t;\n            dfs2(t);\n        }\n    }\n}\n\ninline int lca(int x, int y) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] > dep[top[y]])\n            x = fa[top[x]];\n        else\n            y = fa[top[y]];\n    }\n    if (dep[x] < dep[y])\n        return x;\n    else\n        return y;\n}\n\n// 以结点的dfn排序建立线段树，可以通过rnk反求结点编号\nll sum[N << 2], laz[N << 2];\nll build(int l = 1, int r = n, int p = 1) {\n    if (l == r) return sum[p] = w[rnk[l]];\n    int m = l + r >> 1, ps = p << 1;\n    return sum[p] = build(l, m, ps) + build(m + 1, r, ps | 1);\n}\n\ninline void pd(int l, int r, int p) {\n    if (laz[p] == 0 || l == r) return;\n    int m = l + r >> 1, ps = p << 1;\n    sum[ps] += laz[p] * (m - l + 1);\n    laz[ps] += laz[p];\n    sum[ps | 1] += laz[p] * (r - m);\n    laz[ps | 1] += laz[p];\n    laz[p] = 0;\n}\n\nvoid chg(int s, int t, ll k, int l = 1, int r = n, int p = 1) {\n    if (s > t) swap(s, t);  // 重要！！！\n    if (s == l && t == r) {\n        sum[p] += k * (r - l + 1);\n        laz[p] += k;\n        return;\n    }\n    pd(l, r, p);  // 重要！！！\n    int m = l + r >> 1, ps = p << 1;\n    if (s <= m) chg(s, min(t, m), k, l, m, ps);\n    if (t > m) chg(max(s, m + 1), t, k, m + 1, r, ps | 1);\n    sum[p] = sum[ps] + sum[ps | 1];\n}\n\nll qry(int s, int t, int l = 1, int r = n, int p = 1) {\n    if (s > t) swap(s, t);  // 重要！！！\n    if (s == l && t == r) return sum[p];\n    pd(l, r, p);  // 重要！！！\n    int m = l + r >> 1, ps = p << 1;\n    ll re = 0;\n    if (s <= m) re += qry(s, min(t, m), l, m, ps);\n    if (t > m) re += qry(max(s, m + 1), t, m + 1, r, ps | 1);\n    return re;\n}\n\ninline void init() {\n    dep[r] = 1;\n    dfs1();\n    top[r] = r;\n    dfs2();\n    build();\n}\n\ninline void case1() {\n    int x, y, z;\n    read(x), read(y), read(z);\n    int L = lca(x, y);\n    while (top[x] != top[L]) {\n        chg(dfn[x], dfn[top[x]], z);\n        x = fa[top[x]];\n    }\n    chg(dfn[x], dfn[L], z);\n    while (top[y] != top[L]) {\n        chg(dfn[y], dfn[top[y]], z);\n        y = fa[top[y]];\n    }\n    chg(dfn[y], dfn[L], z);\n    chg(dfn[L], dfn[L], -z);\n}\n\ninline void case2() {\n    int x, y;\n    read(x), read(y);\n    int L = lca(x, y);\n    ll ans = 0;\n    while (top[x] != top[L]) {\n        ans += qry(dfn[x], dfn[top[x]]);\n        x = fa[top[x]];\n    }\n    ans += qry(dfn[x], dfn[L]);\n    while (top[y] != top[L]) {\n        ans += qry(dfn[y], dfn[top[y]]);\n        y = fa[top[y]];\n    }\n    ans += qry(dfn[y], dfn[L]);\n    ans -= qry(dfn[L], dfn[L]);\n    printf(\"%lld\\n\", ans % P);\n}\n\ninline void case3() {\n    int x, z;\n    read(x), read(z);\n    chg(dfn[x], dfn[x] + siz[x] - 1, z);\n}\n\ninline void case4() {\n    int x;\n    read(x);\n    ll ans = qry(dfn[x], dfn[x] + siz[x] - 1);\n    printf(\"%lld\\n\", ans % P);\n}\n\nsigned main() {\n    cin >> n >> m >> r >> P;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1, x, y; i < n; ++i) {\n        read(x), read(y);\n        add(x, y), add(y, x);\n    }\n    init();\n    for (int i = 1, op; i <= m; ++i) {\n        read(op);\n        switch (op) {\n            case 1: case1(); break;\n            case 2: case2(); break;\n            case 3: case3(); break;\n            case 4: case4(); break;\n        }\n    }\n\n    return 0;\n}\n```\n\\\n#ST表 \n```cpp\nconst int L = 22;\nint Log[N], ma[N][L];\ninline void init() {\n    Log[1] = 0;\n    for (int i = 2; i < N; ++i)\n        Log[i] = Log[i >> 1] + 1;\n\n    for (int i = 1; i <= n; ++i) ma[i][0] = a[i];\n    for (int j = 1; j <= L; ++j)\n        for (int i = 1; i + (1 << j) - 1 <= n; ++i)\n            ma[i][j] = max(ma[i][j - 1], ma[i + (1 << j - 1)][j - 1]);\n}\n\ninline int qry_max(int l, int r) {\n    int q = Log[r - l + 1];\n    return max(ma[l][q], ma[r - (1 << q) + 1][q]);\n}\n```\n\\\n#二叉搜索树 #平衡树\n#AVL树\n#Splay树\n\\\n#可持久化数据结构\n***\n### 数论\n#线性筛 #欧拉函数 \n```cpp\nint ps[N], phi[N], tot = 0;\nbool vis[N];\ninline void init() {\n    for (int i = 2; i < N; ++i) {\n        if (!vis[i])\n            ps[++tot] = i, phi[i] = i - 1;\n        for (int j = 1; j <= tot; ++j) {\n            int p = ps[j], t = i * p;\n            if (t >= N) break;\n            vis[t] = true;\n            if (i % p)\n                phi[t] = phi[i] * phi[p];\n            else {\n                phi[t] = phi[i] * p;\n                break;\n            }\n        }\n    }\n}\n```\n若要求$\\varphi(x)$（$x$很大），则需要对$x$进行质因数分解，然后利用$\\varphi(x)$的积性来计算，其中需要$N>\\sqrt{x}$\n\\\n#快速幂 \n```cpp\nll qpow(ll a, ll n) {\n    a %= P;\n    ll re = 1;\n    while (n) {\n        if (n & 1) re = re * a % P;\n        a = a * a % P;\n        n >>= 1;\n    }\n    return re;\n}\n```\n\\\n#EXGCD\n求$ax+by=\\gcd(a,b)$的一组可行解\n```cpp\nint Exgcd(int a, int b, int& x, int& y) {\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = Exgcd(b, a % b, x, y);\n    int t = x;\n    x = y;\n    y = t - (a / b) * y;\n    return d;\n}\n```\n函数返回的值为$\\gcd$，在这个过程中计算$x,y$即可\n***\n### 图论\n#树上问题\n\\\n#最短路\n#Floyd \n```cpp\nfor (k = 1; k <= n; k++) {\n  for (x = 1; x <= n; x++) {\n    for (y = 1; y <= n; y++) {\n      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);\n    }\n  }\n}\n```\n#Dijkstra \n```cpp\nstruct edge {\n  int v, w;\n};\n\nstruct node {\n  int dis, u;\n\n  bool operator>(const node& a) const { return dis > a.dis; }\n};\n\nvector<edge> e[maxn];\nint dis[maxn], vis[maxn];\npriority_queue<node, vector<node>, greater<node> > q;\n\nvoid dijkstra(int n, int s) {\n  memset(dis, 63, sizeof(dis));\n  dis[s] = 0;\n  q.push({0, s});\n  while (!q.empty()) {\n    int u = q.top().u;\n    q.pop();\n    if (vis[u]) continue;\n    vis[u] = 1;\n    for (auto ed : e[u]) {\n      int v = ed.v, w = ed.w;\n      if (dis[v] > dis[u] + w) {\n        dis[v] = dis[u] + w;\n        q.push({dis[v], v});\n      }\n    }\n  }\n}\n```\n\\\n#分层图 \n\\\n#欧拉回路\n\\\n#网络流\n***\n### 动态规划\n#背包DP\n#01背包 \n$$f_{i,j}=\\max\\{f_{i-1,j},f_{i-1,j-w_i}+v_i\\}$$\n滚动数组优化：\n$$f_j=\\max\\{f_j,f_{j-w_i}+v_i\\}$$\n需要`j`从大到小遍历\n```cpp\nfor (int i = 1; i <= n; i++)\n    for (int j = W; j >= w[i]; j--)\n        f[j] = max(f[j], f[j - w[i]] + v[i]);\n```\n#完全背包 \n$$f_{i,j}=\\max_{k=0}^{+\\infty}\\{f_{i-1,j-k\\cdot w_i}+k\\cdot v_i\\}$$\n同样采用滚动数组优化，`j`从小到大遍历\n```cpp\nfor (int i = 1; i <= n; i++)\n    for (int j = w[i]; j <= W; j++)\n        if (f[j - w[i]] + v[i] > f[j]) f[j] = f[j - w[i]] + v[i];\n```\n\\\n#区间DP\n#DAG上的DP\n#树形DP\n#状压dp \n#数位dp \n#插头DP\n#计数DP\n***\n### 字符串\n#字典树 #Trie\n```cpp\nstruct trie {\n    int nex[100000][26], cnt;\n    bool exist[100000];  // 该结点结尾的字符串是否存在\n\n    void insert(char* s, int l) {  // 插入字符串\n        int p = 0;\n        for (int i = 0; i < l; i++) {\n            int c = s[i] - 'a';\n            if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点\n            p = nex[p][c];\n        }\n        exist[p] = 1;\n    }\n\n    bool find(char* s, int l) {  // 查找字符串\n        int p = 0;\n        for (int i = 0; i < l; i++) {\n            int c = s[i] - 'a';\n            if (!nex[p][c]) return 0;\n            p = nex[p][c];\n        }\n        return exist[p];\n    }\n};\n```\n\\\n#前缀数组\n$$\\pi[i]=\\max_{k=0,...,i}\\{\\ k\\ |\\ s[0..k-1]=s[i-k+1..i]\\ \\}$$\n```cpp\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n        if (s[i] == s[j]) j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n```\n\\\n#KMP算法\n```cpp\nvector<int> find_occurrences(string text, string pattern) {\n    string cur = pattern + '#' + text;\n    int sz1 = text.size(), sz2 = pattern.size();\n    vector<int> v;\n    vector<int> lps = prefix_function(cur);\n    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {\n        if (lps[i] == sz2) v.push_back(i - 2 * sz2);\n    }\n    return v;\n}\n```\n\\\n#AC自动机\n\\\n#后缀数组\n`sa[i]`表示将所有后缀排序后第`i`小的后缀的编号\n`rk[i]`表示后缀`i`的排名，即`sa[rk[i]] = rk[sa[i]] = i`\n![[后缀数组.png]]\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int N = 1000010;\n\nchar s[N];\n// key1[i] = rk[id[i]]（作为基数排序的第一关键字数组）\nint n, sa[N], rk[N], oldrk[N << 1], id[N], key1[N], cnt[N];\n\nbool cmp(int x, int y, int w) {\n    return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];\n}\n\nint main() {\n    int i, m = 127, p, w;\n\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    for (i = 1; i <= n; ++i)\n        ++cnt[rk[i] = s[i]];\n    for (i = 1; i <= m; ++i)\n        cnt[i] += cnt[i - 1];\n    for (i = n; i >= 1; --i)\n        sa[cnt[rk[i]]--] = i;\n\n    for (w = 1;; w <<= 1, m = p) {  // m=p 就是优化计数排序值域\n        for (p = 0, i = n; i > n - w; --i)\n            id[++p] = i;\n        for (i = 1; i <= n; ++i)\n            if (sa[i] > w) id[++p] = sa[i] - w;\n\n        memset(cnt, 0, sizeof(cnt));\n        for (i = 1; i <= n; ++i)\n            ++cnt[key1[i] = rk[id[i]]];\n        // 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组\n\n        for (i = 1; i <= m; ++i)\n            cnt[i] += cnt[i - 1];\n        for (i = n; i >= 1; --i)\n            sa[cnt[key1[i]]--] = id[i];\n        memcpy(oldrk + 1, rk + 1, n * sizeof(int));\n        for (p = 0, i = 1; i <= n; ++i)\n            rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;\n        if (p == n) {\n            break;\n        }\n    }\n\n    for (i = 1; i <= n; ++i)\n        printf(\"%d \", sa[i]);\n\n    return 0;\n}\n```\n\\\n#后缀自动机\n***\n### 计算几何\n#平面最近点对 \n遍历方法\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<double, double> pdd;\n\nconst int N = 100005;\nint n;\npdd a[N];\nstruct cmp {\n    bool operator()(const pdd& p1, const pdd& p2) const {\n        return p1.second < p2.second;\n    }\n};\nmultiset<pdd, cmp> ms;\n\ninline double d(const pdd& p1, const pdd& p2) {\n    return sqrt((p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second));\n}\n\nsigned main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i].first >> a[i].second;\n    }\n    sort(a, a + n);\n    double ans = 1e10;\n    for (int i = 0, j = 0; i < n; ++i) {\n        for (; j < i && a[i].first - a[j].first >= ans; ++j) ms.erase(ms.find(a[j]));\n        for (multiset<pdd, cmp>::iterator it = ms.lower_bound(make_pair(0, a[i].second - ans));\n             it != ms.end() && it->second - a[i].second < ans; ++it) {\n            ans = min(ans, d(*it, a[i]));\n        }\n        ms.insert(a[i]);\n    }\n\n    cout << fixed << setprecision(4) << ans;\n\n    return 0;\n}\n```\n\\\n#扫描线\n***\n### 杂项\n#逆波兰式 \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define Inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\n// #define int long long\n\nint pri[128];\ninline void init() {\n    pri['+'] = pri['-'] = 1;\n    pri['*'] = pri['/'] = 2;\n    pri['^'] = 3;\n}\n\ninline ll qpow(ll a, ll n) {\n    ll re = 1;\n    while (n) {\n        if (n & 1) re *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return re;\n}\n\ninline ll cal(ll a, ll b, char op) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return a / b;\n        case '^': return qpow(a, b);\n    }\n    return 0;\n}\n\nlist<ll> dfs(int pre = 0) { // pre代表在最前面添加\"(\"的个数\n    list<ll> re;\n    if (pre > 0) re.splice(re.end(), dfs(pre - 1));\n    stack<char> op;\n    char c;\n    while (cin >> c) {\n    begin:\n        if (c == '(') re.splice(re.end(), dfs());\n        else if (c == ')') break;\n        else if (pri[c]) {\n            while (!op.empty() && pri[op.top()] >= pri[c]) {\n                re.push_back(op.top() + INF);\n                op.pop();\n            }\n            op.push(c);\n        }\n        else {\n            ll a = c - '0';\n            while (cin >> c) {\n                if (!isdigit(c)) {\n                    re.push_back(a);\n                    goto begin;\n                }\n                a = a * 10 + c - '0';\n            }\n            re.push_back(a);\n        }\n    }\n    while (!op.empty()) {\n        re.push_back(op.top() + INF);\n        op.pop();\n    }\n    return re;\n}\n\ninline void show(list<ll>& a) {\n    for (ll& i : a) {\n        if (i > INF) cout << char(i - INF) << ' ';\n        else cout << i << ' ';\n    }\n    cout << '\\n';\n}\n\ninline void work(list<ll>& a) {\n    // show(a);\n    for (auto it = a.begin(); it != a.end(); ++it) {\n        if (*it < INF) continue;\n        char op = char(*it - INF);\n        ll p = *prev(prev(it)), q = *prev(it);\n        *it = cal(p, q, op);\n        a.erase(prev(it));\n        a.erase(prev(it));\n        // show(a);\n    }\n}\n\nsigned main() {\n    init();\n    list<ll> a = dfs(30);\n    //\tshow(a);\n    work(a);\n    if (a.empty()) cout << 0;\n    else show(a);\n\n    return 0;\n}\n\n/*\n\n5+6)*7^8)\n\n*/\n\n```\n\\\n#双指针 \n\\\n#离散化\n\n","tags":["算法"],"categories":["computer-science"]},{"title":"电路知识点速记","url":"/2024/08/20/test002/","content":"\n\n***\n\n注意：\n1. 本文相关教材：电路（慕课版 支持AR+H5交互）邹建龙 著 人民邮电出版社\n2. 本文为纯干货，建议配合课本复习，并辅以实战练习\n3. 本文无图，如有图片需求，请到课本对应章节查看\n4. 本文为了使某些内容更容易被理解和记忆，特地转换了表述\n5. 本文或许存在一些纰漏，读者应当仔细甄别、理性对待\n\n***\n#### 第1章 电路概论\n\n已学内容全部为：线性电路、集总参数电路\n\n***\n### ==第一篇 电路基本概念和分析基础==\n***\n#### 第2章 电路基本概念\n\n标定电压、电流方向：参考方向 √   真实方向 ×\n\n#关联参考方向 电流从电压正极流入\n功率：$p=ui$\n关联参考方向下：$p>0$，实际吸收功率；$p<0$，实际发出功率。非关联反之。\n\n#电路基本元件 （以下全为关联参考方向）\n* 电阻：$u=Ri$，$p=ui=i^2 R=\\frac{u^2}{R}$\n* 电容：$i=C\\frac{\\mathrm{d}u}{\\mathrm{d}t}$\n* 电感：$u=L\\frac{\\mathrm{d}i}{\\mathrm{d}t}$\n* 独立电压源、独立电流源、电压/电流控制电压/电流源\n\n#电路拓扑\n支路$b$，节点$n$，网孔$m=b-n+1$\n串联、并联、其他\n\n***\n#### 第3章 电路基本定理\n\n#基尔霍夫定律\n* 电流定律（KCL）：节点电流代数和为$0$  →  $n-1$个独立方程\n* 电压定律（KVL）：回路电压代数和为$0$  →  $m$个独立方程\n\n***\n#### 第4章 电路基本分析方法\n\n#等效变换 对外等效、对内不等效\n+ 电阻等效\n\t+ 串联：$R_\\mathrm{eq}=\\sum\\limits_{i}{R_i}$\n\t+ 并联：$\\frac{1}{R_\\mathrm{eq}}=\\sum\\limits_{i}{\\frac{1}{R_i}}$\n\t+ △形→Y形：$R_{ij}=R_i R_j \\sum\\limits_{k}{\\frac{1}{R_k}}$\n\t+ Y形→△形：$R_i=\\frac{R_{ij} R_{ik}}{R_{ij}+R_{ik}+R_{jk}}$\n* 电源等效\n\t+ 电压源串联$u_{\\mathrm{s}}$相加，电流源并联$i_{\\mathrm{s}}$相加\n* 电源、电阻混合等效\n\t+ 等效模型：电压源$u_\\mathrm{s}$与电阻$R_u$并联 ⇆ 电流源$i_\\mathrm{s}$与电阻$R_i$串联\n\t+ $R_u=R_i$，$i_\\mathrm{s}=\\frac{u_\\mathrm{s}}{R_u}$，$u_\\mathrm{s}=i_\\mathrm{s} R_i$\n\n#节点电压法 \n$n-1$个方程：自导项 - 互导项 = 电源产生电流项\n\n#回路电流法\n$m$个方程：自阻项 - 互阻项 = 电源产生电压项\n\n*以上内容建议实操练习，在实战中总结更多技巧*\n\n***\n#### 第5章 电路定理\n\n#线性定理\n（用$x$表示待求电压/电流，$s_i$表示第$i$个独立电压/电流源）\n* 叠加定理：$$x=f(s_1,s_2,\\ldots,s_n)\\Rightarrow x=\\sum\\limits_{i}f(\\delta_{i1}s_1,\\delta_{i2}s_2,\\ldots,\\delta_{in}s_n)$$\n* 齐性定理：（$k$为常数）$$x=f(k s_i)\\Rightarrow x=kf(s_i)$$\n* 二者结合：$$x=f(k_1 s_1,k_2 s_2,\\ldots,k_n s_n)\\Rightarrow x=\\sum\\limits_{i}k_i f(\\delta_{i1}s_1,\\delta_{i2}s_2,\\ldots,\\delta_{in}s_n)$$\n\n#替代定理\n参量为$u、i$的支路可被替换为电压源$u_\\mathrm{s}=u$，或电流源$i_\\mathrm{s}=i$，或电阻$R=\\frac{u}{i}$\n\n#戴维南定理\n线性含源一端口网络可以用一个电压源和一个电阻串联来等效，该电压源的电压为一端口网络的端口开路电压$u_{\\mathrm{oc}}$，该电阻的阻值为一端口网络内独立电源置零后的端口等效电阻$R_{\\mathrm{eq}}$\n一步法：给端口接一个$u_\\mathrm{s}、i_\\mathrm{s}$（非关联）的电源，最后可求得：$u_\\mathrm{s}=u_{\\mathrm{oc}}+R_{\\mathrm{eq}}i_\\mathrm{s}$\n\n#诺顿定理\n戴维南等效的“电流源版本”\n\n最大功率传输：当$R=R_{\\mathrm{eq}}$时，$P_{\\max}=\\frac{u_{\\mathrm{oc}}^2}{4R_{\\mathrm{eq}}}$\n\n#特勒根定理\n* 定理一：关联参考方向下，$$\\sum\\limits_{k=1}^{b}{u_k i_k}=0$$\n* 定理二：两对应电路*（规定见课本）*，$$\\sum\\limits_{k=1}^{b}{u_k \\hat{i}_k}=\\sum\\limits_{k=1}^{b}{\\hat{u}_k i_k}=0$$\n* 定理二的推论：两对应电路，除线性电阻网络外，$$\\sum\\limits_{k=1}^{r}{u_k \\hat{i}_k}=\\sum\\limits_{k=1}^{r}{\\hat{u}_k i_k}$$\n\n#互易定理\n对二端口网络的两端分别施加激励，$$\\frac{激励1}{响应1}=\\frac{激励2}{响应2}$$\n\n#对偶原理\n*有兴趣请见课本*\n\n***\n### ==第二篇 动态电路的时域分析==\n***\n#### 第6章 动态电路的动态元件和微分方程\n\n#电容\nVCR：$i=C\\frac{\\mathrm{d}u}{\\mathrm{d}t}$ 或 $u(t)=u(t_0)+\\frac{1}{C}\\int_{t_0}^{t}i(\\xi)\\mathrm{d}\\xi$\n能量：$w=\\frac{1}{2}Cu^2$\n等效变换：（与电阻相反）\n* 串联：$\\frac{1}{C_\\mathrm{eq}}=\\sum\\limits_{i}{\\frac{1}{C_i}}$\n* 并联：$C_\\mathrm{eq}=\\sum\\limits_{i}{C_i}$\n平行板电容器：$C=\\varepsilon\\frac{S}{d}$\n\n#电感\nVCR：$u=C\\frac{\\mathrm{d}i}{\\mathrm{d}t}$ 或 $i(t)=i(t_0)+\\frac{1}{L}\\int_{t_0}^{t}u(\\xi)\\mathrm{d}\\xi$\n能量：$w=\\frac{1}{2}Li^2$\n等效变换：（与电阻相反）\n* 串联：$L_\\mathrm{eq}=\\sum\\limits_{i}{L_i}$\n* 并联：$\\frac{1}{L_\\mathrm{eq}}=\\sum\\limits_{i}{\\frac{1}{L_i}}$\n\n#动态电路的定解问题\n* 微分方程：KVL + KCL + VCR 方程组联立  →  关于电流/电压的$n$阶常系数线性微分方程\n* 初始条件：$u_C(0_+)=u_C(0_-)$ 以及 $i_L(0_+)=i_L(0_-)$ + 以上方程组  →  关于电流/电压的$n$阶常系数线性微分方程的$n$个初始条件\n* 特殊情况：$u_C(t)$或$i_L(t)$在$t=0$时刻发生突变，此时应对某个方程进行$t=0_-$到$t=0_+$的积分，才能求出$u_C(0_+)$ 或 $i_L(0_+)$。*(详见课本$P_{135}$的例子）*\n\n***\n#### 第7章 一阶动态电路\n\n*电容、电感的充、放电方程见课本*\n\n#三要素公式 \n电容电压：\n$$u_C(t)=u_C(\\infty)+[u_C(0_+)-u_C(\\infty)]\\mathrm{e}^{-\\frac{t}{\\tau}}$$\n其中：\n$$\\tau=CR_{\\mathrm{eq}}$$\n电感电流：\n$$i_L(t)=i_L(\\infty)+[i_L(0_+)-i_L(\\infty)]\\mathrm{e}^{-\\frac{t}{\\tau}}$$\n其中：\n$$\\tau=\\frac{L}{R_{\\mathrm{eq}}}$$\n\n#一阶电路的响应\n由叠加定理得，\n$$全响应=零状态响应+零输入响应$$\n阶跃函数：\n$$\n\\varepsilon \\left( t \\right) =\\begin{cases}\n\t0,t<0\\\\\n\t1,t>0\\\\\n\\end{cases}\n$$\n冲激函数：\n$$\\delta(t)=\\frac{\\mathrm{d}}{\\mathrm{d}t}\\varepsilon(t)$$\n求解阶跃响应只需先求各组分阶跃函数的响应，再由叠加定理叠加便可得最终解。\n求解冲激响应只需先求解对应的阶跃响应，然后对阶跃响应求导便可得冲激响应。\n\n***\n#### 第8章 二阶动态电路\n\n定解问题为二阶微分方程\n\n求解二阶微分方程：\n特征方程  →  特征根$\\lambda_1,\\lambda_2$  →  齐次通解：\n$$\\lambda_1=\\lambda_2 \\Rightarrow y=(A+Bt)\\mathrm{e}^{\\lambda t}$$\n$$\\lambda_1\\ne\\lambda_2 \\Rightarrow y=\\mathrm{Re}(A\\mathrm{e}^{\\lambda_1 t}+B\\mathrm{e}^{\\lambda_2 t})$$\n*（这里是为了方便记忆，出现复指数则用欧拉公式展开成三角函数表示）*\n\n（如果是非齐次方程：凑出非齐次特解  →  原方程通解为：齐次通解 + 非齐次特解）\n\n最后：待定系数，由初始条件定解\n\n#RLC串联电路的工作状态\n* 过阻尼：$R>2\\sqrt{\\frac{L}{C}}$  →  单调衰减\n* 临界阻尼：$R=2\\sqrt{\\frac{L}{C}}$  →  单调衰减，但衰减相比于过阻尼更快\n* 欠阻尼：$0<R<2\\sqrt{\\frac{L}{C}}$  →  震荡衰减\n* 零阻尼：$R=0$  →  等幅振荡，不衰减\n\n*其他二阶电路，见课本*\n\n***\n### ==第三篇 正弦交流电路==\n***\n#### 第9章 正弦交流电路分析基础\n\n正弦量：\n$$f(t)=F_\\mathrm{m}\\cos(\\omega t+\\varphi)=\\mathrm{Re}[F_\\mathrm{m}\\mathrm{e}^{\\mathrm{j}(\\omega t+\\varphi)}]$$\n振幅相量：（以电流为例）\n$$\\dot{I}_\\mathrm{m}=I_\\mathrm{m}\\mathrm{e}^{\\mathrm{j}\\varphi}$$\n#有效值相量\n$$\\dot{I}=I\\mathrm{e}^{\\mathrm{j}\\varphi}=I\\angle\\varphi$$\n其中：\n$$I=\\frac{1}{T}\\sqrt{\\int_0^T i^2(t)\\mathrm{d}t}$$\n在正弦交流电路中，有：\n$$I=\\frac{I_\\mathrm{m}}{\\sqrt{2}}$$\n\n#相量域中的VCR\n$$\n\\begin{array}{c}\n\t\\dot{U}_R=R\\dot{I}_R\\\\\n\t\\dot{U}_L=\\mathrm{j}\\omega L\\dot{I}_L\\\\\n\t\\dot{I}_C=\\mathrm{j}\\omega C\\dot{U}_C\\\\\n\\end{array}\n$$\n\n#阻抗\n$$Z=\\frac{\\dot{U}}{\\dot{I}}=R+\\mathrm{j}X=|Z|\\angle{\\varphi_Z}=\\frac{U}{I}\\angle(\\varphi_{u}-\\varphi_{i})$$\n对基本元件，有：\n$$\n\\begin{array}{c}\n\tZ_R=R\\\\\n\tZ_L=\\mathrm{j}\\omega L\\\\\n\tZ_C=\\frac{1}{\\mathrm{j}\\omega C}\\\\\n\\end{array}\n$$\n\n#导纳\n$$Y=\\frac{1}{Z}=\\frac{\\dot{I}}{\\dot{U}}=G+\\mathrm{j}B$$\n\n***\n#### 第10章 正弦交流电路的相量分析法\n\n#代数方法\n具体方法同第一篇内容，只是变量从实数域变到了复数域\n\n将时域正弦量转换为相量  →  用电路定理求解  →  将相量转换回正弦量\n\n#相量图\n实际上是电路方程通过复数的几何意义映射到复平面中的首尾相接矢量多边形\n\n列写方程  →  确定参考相量  →  依次绘制其他相量  →  构成多边形，找几何关系，求解\n\n重要关系：\n* 电阻电压与电流同相位，即：$\\varphi_{u}-\\varphi_{i}=0\\degree$\n* 电感电压超前电流$90\\degree$，即：$\\varphi_{u}-\\varphi_{i}=90\\degree$\n* 电容电压滞后电流$90\\degree$，即：$\\varphi_{u}-\\varphi_{i}=-90\\degree$\n\n*以上内容建议实操练习，在实战中总结更多技巧*\n\n***\n#### 第11章 正弦交流电路的功率\n\n#瞬时功率\n$$p(t)=u(t)i(t)$$\n\n#复功率\n$$\\bar{S}=P+\\mathrm{j}Q=UI\\mathrm{e}^{\\mathrm{j}(\\varphi_{u}-\\varphi_{i})}=\\dot{U}\\dot{I}^*=I^2Z=\\frac{U^2}{Z^*}$$\n*（代入VCR即可推出电阻、电感、电容的复功率表达式，不建议死记）*\n\n#有功功率$$P=\\mathrm{Re}(\\bar{S})=UI\\cos(\\varphi_{u}-\\varphi_{i})$$\n#最大有功功率传输\n可变负载幅角和模值：当 $Z=Z_\\mathrm{eq}^*$ 时，$P_\\max=\\frac{U_\\mathrm{oc}^2}{4R_\\mathrm{eq}}$\n仅可变负载模值：当 $|Z|=|Z_\\mathrm{eq}|$ 时，$P_\\max=\\ldots$\n\n#无功功率$$Q=\\mathrm{Im}(\\bar{S})=UI\\sin(\\varphi_{u}-\\varphi_{i})$$\n\n#视在功率\n$$S=|S|=UI$$\n\n#功率因数\n$$\\cos\\varphi=\\cos(\\varphi_{u}-\\varphi_{i})=\\frac{P}{S}$$\n\n#功率守恒\n$\\bar{S}$ 守恒（对所有电路元件的代数和为$0$），即 $P,Q$ 守恒\n$S$ 不一定守恒\n\n***\n### ==第四篇 电路应用与拓展==\n***\n#### 第12章 三相电路\n\n#三相 （正序，顺时针）\n$$\\dot{U}_\\mathrm{A}=U\\angle0\\degree,\\;\\dot{U}_\\mathrm{B}=U\\angle-120\\degree,\\;\\dot{U}_\\mathrm{C}=U\\angle120\\degree$$\n有：\n$$\\dot{U}_\\mathrm{A}+\\dot{U}_\\mathrm{B}+\\dot{U}_\\mathrm{C}=0$$\n相量图：略\n\n注意区分：*（详见书）*\n* 相电压、相电流、线电压、线电流\n* 电压源/负载的Y形/△形接法\n\n#对称三相电路\n将△形变换为Y形  →  所有中性点$\\dot{U}_\\mathrm{N'}=0$，等效变换化简  →  求解\n\n#不对称三相电路\n回归到一般的相量法求解\n\n#功率表\n读数：$P=\\mathrm{Re}(\\dot{U}\\dot{I}^*)$\n（注意：这里的 $\\dot{U}$ 和 $\\dot{I}$ 不一定恰好是同一支路的，只有是同一支路$P$才表示有功功率）\n\n二瓦计法：\n$$P_1+P_2=\\mathrm{Re}(\\dot{U}_\\mathrm{AB}\\dot{I}_\\mathrm{A}^*)+\\mathrm{Re}(\\dot{U}_\\mathrm{CB}\\dot{I}_\\mathrm{C}^*)=P_\\mathrm{A}+P_\\mathrm{B}+P_\\mathrm{C}$$\n*详细的接法见课本*\n\n***\n#### 第13章 磁耦合电路\n\n#同名端\n同名端流入电流产生的磁场相互增强\n\n#互感电压\n电流、电压为关联参考方向，电流从同名端流入时：\n时域：\n$$\n\\begin{cases}\n\tu_1=L_1\\frac{\\mathrm{d}i_1}{\\mathrm{d}t}+M\\frac{\\mathrm{d}i_2}{\\mathrm{d}t}\\\\\n\tu_2=L_2\\frac{\\mathrm{d}i_2}{\\mathrm{d}t}+M\\frac{\\mathrm{d}i_1}{\\mathrm{d}t}\\\\\n\\end{cases}\n$$\n相量域：\n$$\n\\begin{cases}\n\t\\dot{U}_1=\\mathrm{j}\\omega L_1\\dot{I}_1+\\mathrm{j}\\omega M\\dot{I}_2\\\\\n\t\\dot{U}_2=\\mathrm{j}\\omega L_2\\dot{I}_2+\\mathrm{j}\\omega M\\dot{I}_1\\\\\n\\end{cases}\n$$\n\n其他情况，应 #判断互感电压的极性 ：\n自己线圈流入电流的端子对应对方线圈的同名端上的互感电压极性为$+$。\n\n#去耦等效\n互感系数可以叠加到两个电感上（耦合同方向串联为$+$，反之为$-$），并在中间支路上叠加一个与前面的叠加项相反的电感。*（详见课本）*\n\n#变压器\n耦合系数：\n$$k=\\frac{M}{\\sqrt{L_1L_2}}$$\n全耦合：$k=1$\n\n#阻抗变换\n输入阻抗：\n$$Z_\\mathrm{in}=\\mathrm{j}\\omega L_1+\\frac{(\\omega M)^2}{Z_2+\\mathrm{j}\\omega L_2}$$\n输出阻抗：\n$$Z_\\mathrm{out}=\\mathrm{j}\\omega L_2+\\frac{(\\omega M)^2}{Z_1+\\mathrm{j}\\omega L_1}$$\n*（死记不到，建议现推）*\n\n去耦等效：连接变压器下方的两个端子，即可用上述方法进行去耦等效\n\n#理想变压器\n定义：无损耗、全耦合、$L_1,L_2,M\\rightarrow \\infty$\n性质：（电流、电压为关联参考方向，电流从同名端流入时；如果不是，请添$-$号来转换）\n* $\\frac{u_1}{u_2}=\\frac{\\dot{U}_1}{\\dot{U}_2}=\\frac{N_1}{N_2}=n$\n* $\\frac{i_1}{i_2}=\\frac{\\dot{I}_1}{\\dot{I}_2}=-\\frac{N_2}{N_1}=-\\frac{1}{n}$\n* 输入功率等于输出功率\n* 阻抗变换：$Z_\\mathrm{in}=\\frac{N_1^2}{N_2^2}Z_2=n^2Z_2$\n\n***\n#### 第14章 滤波器和谐振电路\n\n#传递函数\n$$H(\\mathrm{j}\\omega)=\\frac{输入信号相量}{输出信号相量}$$\n\n#滤波器\n分类：低通、高通、带通\n截止角频率$\\omega_\\mathrm{c}$：$|H(\\mathrm{j}\\omega_\\mathrm{c})|=\\frac{1}{\\sqrt{2}}$\n幅频特性曲线：$|H(\\mathrm{j}\\omega)|-\\omega$ 图像\n\n#谐振\n定义：$\\mathrm{Im}(Z_\\mathrm{eq})=0$\n分类：\n* 串联谐振\n\t* $Z=R+\\mathrm{j}(\\omega L-\\frac{1}{\\omega C})=R$\n\t* $\\omega=\\frac{1}{\\sqrt{LC}}$\n\t* LC整体相当于短路\n* 并联谐振\n\t* $Y=\\frac{1}{R}+\\mathrm{j}(\\omega C-\\frac{1}{\\omega L})=\\frac{1}{R}$\n\t* $\\omega=\\frac{1}{\\sqrt{LC}}$\n\t* LC整体相当于开路\n\n#品质因数\n$$Q=2\\pi\\frac{最大耗能}{一个周期储能}=\\frac{U_L}{U_\\mathrm{s}}或\\frac{U_C}{U_\\mathrm{s}}$$\n$Q$ 越大，带宽越窄，幅频特性曲线越陡，频率选择性越高\n\n串联谐振：\n$$Q=\\frac{\\omega L}{R}=\\frac{1}{R\\omega C}$$\n并联谐振：\n$$Q=\\frac{R}{\\omega L}=R\\omega C$$\n\n***\n#### 第15章 非正弦周期电路\n\n*傅里叶级数，详见课本*\n\n求解：先求各分量的响应，在运用叠加原理即可\n\n#非正弦周期电路的有效值 \n$$\n\\begin{array}{c}\n\tU=\\sqrt{U_{0}^{2}+\\sum\\limits_{n=1}^r{U_{n}^{2}}}\\\\\n\tI=\\sqrt{I_{0}^{2}+\\sum\\limits_{n=1}^r{I_{n}^{2}}}\\\\\n\\end{array}\n$$\n\n#非正弦周期电路的平均功率\n$$P=P_{0}+\\sum\\limits_{n=1}^rP_{n}=I^2R=\\frac{U^2}{R}$$\n\n***\n#### 第16章 二端口网络\n\n二端口网络的定义：$i_1=i'_1,\\;i_2=i'_2$\n\n#阻抗参数\n$$\n\\left[ \\begin{array}{c}\n\t\\dot{U}_1\\\\\n\t\\dot{U}_2\\\\\n\\end{array} \\right] =\\boldsymbol{Z}\\left[ \\begin{array}{c}\n\t\\dot{I}_1\\\\\n\t\\dot{I}_2\\\\\n\\end{array} \\right] \n$$\n#导纳参数\n$$\n\\left[ \\begin{array}{c}\n\t\\dot{I}_1\\\\\n\t\\dot{I}_2\\\\\n\\end{array} \\right] =\\boldsymbol{Y}\\left[ \\begin{array}{c}\n\t\\dot{U}_1\\\\\n\t\\dot{U}_2\\\\\n\\end{array} \\right] \n$$\n#混合参数\n$$\n\\left[ \\begin{array}{c}\n\t\\dot{U}_1\\\\\n\t\\dot{I}_2\\\\\n\\end{array} \\right] =\\boldsymbol{H}\\left[ \\begin{array}{c}\n\t\\dot{I}_1\\\\\n\t\\dot{U}_2\\\\\n\\end{array} \\right] \n$$\n#传输参数\n$$\n\\left[ \\begin{array}{c}\n\t\\dot{U}_1\\\\\n\t\\dot{I}_1\\\\\n\\end{array} \\right] =\\boldsymbol{T}\\left[ \\begin{array}{c}\n\t\\dot{U}_2\\\\\n\t-\\dot{I}_2\\\\\n\\end{array} \\right] \n$$\n\n性质：\n$$\n\\begin{array}{c}\n\tZ_{12}=Z_{21}\\\\\n\tY_{12}=Y_{21}\\\\\n\tH_{12}=-H_{21}\\\\\n\tT_{11}T_{12}-T_{21}T_{12}=1\\\\\n\\end{array}\n$$\n\n等效电路：T形、Π形\n\n连接方式：级联（$\\boldsymbol{T}=\\boldsymbol{T}_1\\boldsymbol{T}_2$）、串联、并联\n\n***\n#### 第17章 含有运算放大器的电路\n\n#特性\n对输入端：\n* 虚断：$i_+=i_-\\approx0$\n* 虚短：$u_+\\approx u_-$\n\n#含运放电路的求解\n1. 完整标记虚短、虚断\n2. 输入端列写KCL\n3. 求解\n\n这部分简单而易错，容易会列出错误的关系式，应当时刻小心。\n\n要注意以下两点：\n* 运放是含源元件，不要在连接运放的回路上乱列KVL\n* 运放输出端电流不满足虚断，不要在输出端乱列KCL\n\n*具体的电路实例详见课本*\n\n***\n\n作者：黄得清\n笔记软件：Obsidian\n时间：2024/1/11\n字数：![[电路文件信息.png]]","tags":["电路"],"categories":["physics"]},{"title":"圆周率的一种无穷级数","url":"/2024/08/20/test001/","content":"\n$$\n\\left( \\frac{1}{2}+\\sum_{n=1}^{\\infty}{\\frac{1}{4n^2+1}} \\right) \\left( \\frac{1}{2}+\\sum_{n=1}^{\\infty}{\\frac{1}{4n^4+1}} \\right) =\\frac{\\pi ^2}{16}\n$$","tags":["级数"],"categories":["maths"]},{"title":"Hello World","url":"/2024/08/19/hello-world/","content":"---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).","tags":["建站"],"categories":["computer-science"]}]